trigger:
  branches:
    include: [ main, qa, prod ]

parameters:
  - name: environment
    type: string
    default: qa
    values: [ qa, prod ]
  - name: projectName
    type: string
    default: kdg-boilerplate
  - name: location
    type: string
    default: eastus

variables:
  # Update the group names below to match your Library â†’ Variable groups names
  - ${{ if eq(parameters.environment, 'qa') }}:
    - group: qa-infra-vars
  - ${{ if eq(parameters.environment, 'prod') }}:
    - group: prod-infra-vars
  - name: ProjectName
    value: ${{ parameters.projectName }}
  - name: Location
    value: ${{ parameters.location }}

stages:
  - stage: Infra
    displayName: Provision Infrastructure
    jobs:
      - job: Terraform
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: TerraformInstaller@1
            inputs:
              terraformVersion: '1.7.5'

          - task: AzureCLI@2
            displayName: Bootstrap Terraform State Storage
            inputs:
              azureSubscription: '$(AzureServiceConnection)'
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                set -euo pipefail
                
                RG_NAME="$(TFSTATE_RG)"
                STORAGE_ACCOUNT_NAME="$(TFSTATE_ACCOUNT)"
                CONTAINER_NAME="$(TFSTATE_CONTAINER)"
                LOCATION="eastus"
                
                echo "Checking if storage account exists..."
                
                # Check if resource group exists, create if not
                if ! az group show --name "$RG_NAME" &>/dev/null; then
                  echo "Creating resource group: $RG_NAME"
                  az group create --name "$RG_NAME" --location "$LOCATION"
                else
                  echo "Resource group already exists: $RG_NAME"
                fi
                
                # Check if storage account exists, create if not
                if ! az storage account show --name "$STORAGE_ACCOUNT_NAME" --resource-group "$RG_NAME" &>/dev/null; then
                  echo "Creating storage account: $STORAGE_ACCOUNT_NAME"
                  az storage account create \
                    --name "$STORAGE_ACCOUNT_NAME" \
                    --resource-group "$RG_NAME" \
                    --location "$LOCATION" \
                    --sku Standard_LRS \
                    --kind StorageV2 \
                    --allow-blob-public-access false \
                    --min-tls-version TLS1_2
                  
                  echo "Storage account created successfully!"
                  echo "Note: Storage Blob Data Contributor role must be granted manually to service principal"
                else
                  echo "Storage account already exists: $STORAGE_ACCOUNT_NAME"
                fi
                
                # Check if container exists, create if not
                if ! az storage container show --name "$CONTAINER_NAME" --account-name "$STORAGE_ACCOUNT_NAME" --auth-mode login &>/dev/null; then
                  echo "Creating container: $CONTAINER_NAME"
                  az storage container create \
                    --name "$CONTAINER_NAME" \
                    --account-name "$STORAGE_ACCOUNT_NAME" \
                    --auth-mode login
                else
                  echo "Container already exists: $CONTAINER_NAME"
                fi
                
                echo "Terraform state storage is ready!"

          - script: |
              set -e
              cat > backend.hcl <<EOF
              resource_group_name  = "$(TFSTATE_RG)"
              storage_account_name = "$(TFSTATE_ACCOUNT)"
              container_name       = "$(TFSTATE_CONTAINER)"
              key                  = "$(ProjectName)-${{ parameters.environment }}.tfstate"
              use_oidc             = true
              use_azuread_auth     = true
              EOF
            displayName: Create backend.hcl

          - task: AzureCLI@2
            displayName: Terraform init/plan/apply
            inputs:
              azureSubscription: '$(AzureServiceConnection)'
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                set -euo pipefail
                
                # Export OIDC authentication variables for Terraform
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                export ARM_USE_OIDC=true
                export ARM_OIDC_TOKEN=$idToken
                
                cd infra/env
                terraform init -backend-config=../../backend.hcl
                terraform plan \
                  -var project_name=$(ProjectName) \
                  -var environment=${{ parameters.environment }} \
                  -var location=$(Location) \
                  -var postgres_admin_password=$(PostgresAdminPassword) \
                  -out=tfplan
                terraform apply -auto-approve tfplan
                terraform output -json > ../../tf-output.json

          - task: AzureCLI@2
            displayName: Apply Key Vault references to App Service
            inputs:
              azureSubscription: '$(AzureServiceConnection)'
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                set -euo pipefail
                KV_NAME=$(jq -r .kv.value.name < tf-output.json)
                RG=$(jq -r .webapp.value.rg < tf-output.json)
                WEBAPP=$(jq -r .webapp.value.name < tf-output.json)
                ENV='${{ parameters.environment }}'

                conn_uri=$(az keyvault secret show --vault-name "$KV_NAME" --name postgres-connection-string-$ENV --query id -o tsv)
                jwt_uri=$(az keyvault secret show --vault-name "$KV_NAME" --name jwt-key-$ENV --query id -o tsv)
                issuer=$(az keyvault secret show --vault-name "$KV_NAME" --name jwt-issuer-$ENV --query value -o tsv)
                audience=$(az keyvault secret show --vault-name "$KV_NAME" --name jwt-audience-$ENV --query value -o tsv)
                base_url=$(az keyvault secret show --vault-name "$KV_NAME" --name app-base-url-$ENV --query value -o tsv)

                az webapp config appsettings set \
                  --resource-group "$RG" \
                  --name "$WEBAPP" \
                  --settings \
                  ConnectionString="@Microsoft.KeyVault(SecretUri=$conn_uri)" \
                  Jwt:Key="@Microsoft.KeyVault(SecretUri=$jwt_uri)" \
                  Jwt:Issuer="$issuer" \
                  Jwt:Audience="$audience" \
                  BaseUrl="$base_url"


