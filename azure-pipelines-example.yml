trigger:
  - [YOUR-TRIGGER-BRANCH]

variables:

  dockerRegistryServiceConnection: '[YOUR-DOCKER-REGISTRY-SERVICE-CONNECTION]' # the name of the service connection in azure devops
  azureResourceServiceConnection: '[YOUR-AZURE-RESOURCE-SERVICE-CONNECTION]' # the name of the service connection in azure devops
  resourceGroupName: '[YOUR-RESOURCE-GROUP-NAME]' # the name of the resource group in azure
  webAppName: '[YOUR-WEBAPP-NAME]' # the name of the Azure Web App for Containers
  postgresServerName: '[YOUR-POSTGRES-SERVER-NAME]' # the name of the postgres server in azure
  imageRepository: '[YOUR-IMAGE-REPOSITORY]' # the name of the image repository in azure
  environment: '[YOUR-ENVIRONMENT]' # the environment to deploy to, used to parse the appsettings.${environment}.json file

  tag: 'latest'
  vmImageName: 'ubuntu-latest'

stages:
- stage: Build
  jobs:
  - job: Build
    pool:
      vmImage: '$(vmImageName)'
    steps:
    # Download environment-specific settings files
    - task: DownloadSecureFile@1
      displayName: 'Download appsettings'
      name: appSettings
      inputs:
        secureFile: 'appsettings.${environment}.json'


    # Copy config files to build context
    - task: CopyFiles@2
      displayName: 'Copy appsettings'
      inputs:
        sourceFolder: '$(Agent.TempDirectory)'
        contents: |
          appsettings.${environment}.json
        targetFolder: '$(Build.SourcesDirectory)'
        overWrite: true

    # Rename config files to their expected names
    - task: Bash@3
      displayName: 'Rename appsettings'
      inputs:
        targetType: 'inline'
        script: |
          mv $(Build.SourcesDirectory)/appsettings.${environment}.json $(Build.SourcesDirectory)/appsettings.json

    # Build the image with the production target stage
    - task: Docker@2
      displayName: 'Build Docker Image for Production'
      inputs:
        command: build
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        buildContext: $(Build.SourcesDirectory)
        tags: |
          $(tag)
          latest
        arguments: '--target final-apm'

    # Get Azure DevOps agent IP
    - task: Bash@3
      displayName: 'Get agent IP'
      name: GetAgentIP
      inputs:
        targetType: 'inline'
        script: |
          AGENT_IP=$(curl -s https://api.ipify.org)
          echo "##vso[task.setvariable variable=AGENT_IP;isOutput=true]$AGENT_IP"

    # Whitelist Azure DevOps agent IP in PostgreSQL Flexible Server
    - task: AzureCLI@2
      displayName: 'Create firewall rule'
      name: CreateFirewallRule
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az postgres flexible-server firewall-rule create \
            --resource-group $(resourceGroupName) \
            --name $(postgresServerName) \
            --rule-name "AzureDevOps-$(Build.BuildId)" \
            --start-ip-address $(GetAgentIP.AGENT_IP) \
            --end-ip-address $(GetAgentIP.AGENT_IP)
          
          # Store the exit code to verify rule was created
          RULE_CREATE_EXIT=$?
          if [ $RULE_CREATE_EXIT -ne 0 ]; then
            echo "Failed to create firewall rule"
            exit $RULE_CREATE_EXIT
          fi

    # Run database migrations
    - task: DotNetCoreCLI@2
      displayName: 'Run migrations'
      inputs:
        command: 'run'
        projects: 'Migrations/Migrations.csproj'
        arguments: '--configuration Release'

    # Always clean up firewall rule
    - task: AzureCLI@2
      displayName: 'Remove firewall rule'
      condition: always()
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az postgres flexible-server firewall-rule delete \
            --resource-group $(resourceGroupName) \
            --name $(postgresServerName) \
            --rule-name "AzureDevOps-$(Build.BuildId)" \
            --yes

    # Push the built image to the registry
    - task: Docker@2
      displayName: 'Push Docker Image to Registry'
      condition: succeeded()
      inputs:
        command: push
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest

    # Download environment-specific .env from Secure Files
    - task: DownloadSecureFile@1
      displayName: 'Download .env for $(environment)'
      name: envFile
      condition: succeeded()
      inputs:
        secureFile: '.env.$(environment)'

    # Copy .env.<environment> to build context
    - task: CopyFiles@2
      displayName: 'Copy .env to build context'
      condition: succeeded()
      inputs:
        sourceFolder: '$(Agent.TempDirectory)'
        contents: |
          .env.$(environment)
        targetFolder: '$(Build.SourcesDirectory)'
        overWrite: true

    # Rename .env.<environment> to .env
    - task: Bash@3
      displayName: 'Rename .env'
      condition: succeeded()
      inputs:
        targetType: 'inline'
        script: |
          mv $(Build.SourcesDirectory)/.env.$(environment) $(Build.SourcesDirectory)/.env

    # Apply .env as App Settings to Azure Web App
    - task: AzureCLI@2
      displayName: 'Apply .env to Azure Web App application settings'
      condition: succeeded()
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          set -euo pipefail
          FILE="$(Build.SourcesDirectory)/.env"
          if [ ! -f "$FILE" ]; then
            echo "Env file not found: $FILE" >&2
            exit 1
          fi
          declare -a SETTINGS
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and blank lines
            if [ -z "$line" ] || [[ "$line" =~ ^# ]]; then
              continue
            fi
            key="${line%%=*}"
            value="${line#*=}"
            # trim CR if present
            value="${value%$'\r'}"
            SETTINGS+=("${key}=${value}")
          done < "$FILE"

          # Always enforce Production for QA/Prod envs by including it in the env file.
          # The .env should contain ASPNETCORE_ENVIRONMENT=Production when appropriate.

          echo "Applying $((${#SETTINGS[@]})) settings to Web App $(webAppName) in RG $(resourceGroupName)"
          az webapp config appsettings set \
            --resource-group "$(resourceGroupName)" \
            --name "$(webAppName)" \
            --settings "${SETTINGS[@]}"