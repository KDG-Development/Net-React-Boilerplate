trigger:
  - [YOUR-TRIGGER-BRANCH]

variables:

  dockerRegistryServiceConnection: '[YOUR-DOCKER-REGISTRY-SERVICE-CONNECTION]' # the name of the service connection in azure devops
  azureResourceServiceConnection: '[YOUR-AZURE-RESOURCE-SERVICE-CONNECTION]' # the name of the service connection in azure devops
  resourceGroupName: '[YOUR-RESOURCE-GROUP-NAME]' # the name of the resource group in azure
  webAppName: '[YOUR-WEBAPP-NAME]' # the name of the Azure Web App for Containers
  postgresServerName: '[YOUR-POSTGRES-SERVER-NAME]' # the name of the postgres server in azure
  imageRepository: '[YOUR-IMAGE-REPOSITORY]' # the name of the image repository in azure
  environment: '[YOUR-ENVIRONMENT]' # the environment to deploy to, used to parse the appsettings.${environment}.json file

  tag: 'latest'
  vmImageName: 'ubuntu-latest'

parameters:
- name: skipUnitTests
  displayName: 'Skip Unit Tests'
  type: boolean
  default: false
- name: skipIntegrationTests
  displayName: 'Skip Integration Tests'
  type: boolean
  default: false

stages:
- stage: Build
  jobs:
  # Uncomment the following jobs to enable testing in your pipeline
  # - job: UnitTests
  #   displayName: 'Run Unit Tests'
  #   condition: eq(${{ parameters.skipUnitTests }}, false)
  #   pool:
  #     vmImage: '$(vmImageName)'
  #   steps:
  #   - task: DotNetCoreCLI@2
  #     displayName: 'Run Unit Tests'
  #     inputs:
  #       command: 'test'
  #       projects: '**/KDG.UnitTests.csproj'
  #       arguments: '--collect "Code Coverage" --settings "./coverage.runsettings"'
  #       publishTestResults: true
  #       publishCodeCoverage: true

  # - job: IntegrationTests
  #   displayName: 'Run Integration Tests'
  #   dependsOn: UnitTests
  #   condition: |
  #     and(
  #       eq(${{ parameters.skipIntegrationTests }}, false),
  #       in(dependencies.UnitTests.result, 'Succeeded', 'Skipped')
  #     )
  #   pool:
  #     vmImage: '$(vmImageName)'
  #   services:
  #     postgres:
  #       image: postgres:16
  #       env:
  #         POSTGRES_USER: postgres
  #         POSTGRES_PASSWORD: postgres
  #         POSTGRES_DB: kdg-integration-test
  #       ports:
  #         - 5432:5432
  #       options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
  #   
  #   steps:
  #   # Download integration test appsettings
  #   - task: DownloadSecureFile@1
  #     displayName: 'Download integration test appsettings'
  #     name: integrationAppSettings
  #     inputs:
  #       secureFile: 'appsettings.IntegrationAzure.json'

  #   # Copy integration test appsettings to test project
  #   - task: CopyFiles@2
  #     displayName: 'Copy integration test appsettings'
  #     inputs:
  #       sourceFolder: '$(Agent.TempDirectory)'
  #       contents: 'appsettings.IntegrationAzure.json'
  #       targetFolder: '$(Build.SourcesDirectory)/KDG.IntegrationTests'
  #       overWrite: true

  #   # Copy integration appsettings to project root (required by Migrations.csproj)
  #   - task: Bash@3
  #     displayName: 'Copy appsettings for migrations'
  #     inputs:
  #       targetType: 'inline'
  #       script: |
  #         cp $(Build.SourcesDirectory)/KDG.IntegrationTests/appsettings.IntegrationAzure.json $(Build.SourcesDirectory)/appsettings.json

  #   # Run database migrations
  #   - task: DotNetCoreCLI@2
  #     displayName: 'Run Database Migrations'
  #     inputs:
  #       command: 'run'
  #       projects: 'Migrations/Migrations.csproj'
  #       arguments: '--configuration Release'

  #   # Run Integration Tests
  #   - task: DotNetCoreCLI@2
  #     displayName: 'Run Integration Tests'
  #     inputs:
  #       command: 'test'
  #       projects: '**/KDG.IntegrationTests.csproj'
  #       arguments: '--verbosity normal --logger trx --collect:"XPlat Code Coverage"'
  #       publishTestResults: true
  #     env:
  #       ASPNETCORE_ENVIRONMENT: 'Test'

  - job: Build
    # Uncomment the following line when enabling test jobs above
    # dependsOn: 
    #   - UnitTests
    #   - IntegrationTests
    # condition: |
    #   and(
    #     notIn(dependencies.UnitTests.result, 'Canceled', 'Failed'),
    #     notIn(dependencies.IntegrationTests.result, 'Canceled', 'Failed')
    #   )
    pool:
      vmImage: '$(vmImageName)'
    steps:
    # Download environment-specific settings files
    - task: DownloadSecureFile@1
      displayName: 'Download appsettings'
      name: appSettings
      inputs:
        secureFile: 'appsettings.$(environment).json'


    # Copy config files to build context
    - task: CopyFiles@2
      displayName: 'Copy appsettings'
      inputs:
        sourceFolder: '$(Agent.TempDirectory)'
        contents: |
          appsettings.$(environment).json
        targetFolder: '$(Build.SourcesDirectory)'
        overWrite: true

    # Rename config files to their expected names
    - task: Bash@3
      displayName: 'Rename appsettings'
      inputs:
        targetType: 'inline'
        script: |
          mv $(Build.SourcesDirectory)/appsettings.$(environment).json $(Build.SourcesDirectory)/appsettings.json

    # Build the image with the production target stage
    - task: Docker@2
      displayName: 'Build Docker Image for Production'
      inputs:
        command: build
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        buildContext: $(Build.SourcesDirectory)
        tags: |
          $(tag)
          latest
        arguments: '--target final-apm'

    # Get Azure DevOps agent IP
    - task: Bash@3
      displayName: 'Get agent IP'
      name: GetAgentIP
      inputs:
        targetType: 'inline'
        script: |
          AGENT_IP=$(curl -s https://api.ipify.org)
          echo "##vso[task.setvariable variable=AGENT_IP;isOutput=true]$AGENT_IP"

    # Whitelist Azure DevOps agent IP in PostgreSQL Flexible Server
    - task: AzureCLI@2
      displayName: 'Create firewall rule'
      name: CreateFirewallRule
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az postgres flexible-server firewall-rule create \
            --resource-group $(resourceGroupName) \
            --name $(postgresServerName) \
            --rule-name "AzureDevOps-$(Build.BuildId)" \
            --start-ip-address $(GetAgentIP.AGENT_IP) \
            --end-ip-address $(GetAgentIP.AGENT_IP)
          
          # Store the exit code to verify rule was created
          RULE_CREATE_EXIT=$?
          if [ $RULE_CREATE_EXIT -ne 0 ]; then
            echo "Failed to create firewall rule"
            exit $RULE_CREATE_EXIT
          fi

    # Run database migrations
    - task: DotNetCoreCLI@2
      displayName: 'Run migrations'
      inputs:
        command: 'run'
        projects: 'Migrations/Migrations.csproj'
        arguments: '--configuration Release'

    # Always clean up firewall rule
    - task: AzureCLI@2
      displayName: 'Remove firewall rule'
      condition: always()
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az postgres flexible-server firewall-rule delete \
            --resource-group $(resourceGroupName) \
            --name $(postgresServerName) \
            --rule-name "AzureDevOps-$(Build.BuildId)" \
            --yes

    # Push the built image to the registry
    - task: Docker@2
      displayName: 'Push Docker Image to Registry'
      condition: succeeded()
      inputs:
        command: push
        repository: $(imageRepository)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest

    # Download environment-specific .env from Secure Files
    - task: DownloadSecureFile@1
      displayName: 'Download .env for $(environment)'
      name: envFile
      condition: succeeded()
      inputs:
        secureFile: '.env.$(environment)'

    # Copy .env.<environment> to build context
    - task: CopyFiles@2
      displayName: 'Copy .env to build context'
      condition: succeeded()
      inputs:
        sourceFolder: '$(Agent.TempDirectory)'
        contents: |
          .env.$(environment)
        targetFolder: '$(Build.SourcesDirectory)'
        overWrite: true

    # Rename .env.<environment> to .env
    - task: Bash@3
      displayName: 'Rename .env'
      condition: succeeded()
      inputs:
        targetType: 'inline'
        script: |
          mv $(Build.SourcesDirectory)/.env.$(environment) $(Build.SourcesDirectory)/.env

    # Apply .env as App Settings to Azure Web App
    - task: AzureCLI@2
      displayName: 'Apply .env to Azure Web App application settings'
      condition: succeeded()
      inputs:
        azureSubscription: '$(azureResourceServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          set -euo pipefail
          FILE="$(Build.SourcesDirectory)/.env"
          if [ ! -f "$FILE" ]; then
            echo "Env file not found: $FILE" >&2
            exit 1
          fi
          declare -a SETTINGS
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and blank lines
            if [ -z "$line" ] || [[ "$line" =~ ^# ]]; then
              continue
            fi
            key="${line%%=*}"
            value="${line#*=}"
            # trim CR if present
            value="${value%$'\r'}"
            SETTINGS+=("${key}=${value}")
          done < "$FILE"

          # Always enforce Production for QA/Prod envs by including it in the env file.
          # The .env should contain ASPNETCORE_ENVIRONMENT=Production when appropriate.

          echo "Applying $((${#SETTINGS[@]})) settings to Web App $(webAppName) in RG $(resourceGroupName)"
          az webapp config appsettings set \
            --resource-group "$(resourceGroupName)" \
            --name "$(webAppName)" \
            --settings "${SETTINGS[@]}"